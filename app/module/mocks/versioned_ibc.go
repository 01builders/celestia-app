// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/cosmos/ibc-go/v9/modules/core/05-port/types (interfaces: IBCModule)
// Package mock_types is a generated GoMock package.
package mock_types

import (
	context "context"
	reflect "reflect"

	types "github.com/cosmos/cosmos-sdk/types"
	types0 "github.com/cosmos/ibc-go/v9/modules/core/02-client/types"
	types1 "github.com/cosmos/ibc-go/v9/modules/core/04-channel/types"
	exported "github.com/cosmos/ibc-go/v9/modules/core/exported"
	"go.uber.org/mock/gomock"
)

// MockIBCModule is a mock of IBCModule interface.
type MockIBCModule struct {
	ctrl     *gomock.Controller
	recorder *MockIBCModuleMockRecorder
}

// MockIBCModuleMockRecorder is the mock recorder for MockIBCModule.
type MockIBCModuleMockRecorder struct {
	mock *MockIBCModule
}

// NewMockIBCModule creates a new mock instance.
func NewMockIBCModule(ctrl *gomock.Controller) *MockIBCModule {
	mock := &MockIBCModule{ctrl: ctrl}
	mock.recorder = &MockIBCModuleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIBCModule) EXPECT() *MockIBCModuleMockRecorder {
	return m.recorder
}

// OnAcknowledgementPacket mocks base method.
func (m *MockIBCModule) OnAcknowledgementPacket(ctx context.Context, channelVersion string, packet types1.Packet, acknowledgement []byte, relayer types.AccAddress) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnAcknowledgementPacket", ctx, channelVersion, packet, acknowledgement, relayer)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnAcknowledgementPacket indicates an expected call of OnAcknowledgementPacket.
func (mr *MockIBCModuleMockRecorder) OnAcknowledgementPacket(ctx, channelVersion, packet, acknowledgement, relayer interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnAcknowledgementPacket", reflect.TypeOf((*MockIBCModule)(nil).OnAcknowledgementPacket), ctx, channelVersion, packet, acknowledgement, relayer)
}

// OnChanCloseConfirm mocks base method.
func (m *MockIBCModule) OnChanCloseConfirm(ctx context.Context, portID, channelID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanCloseConfirm", ctx, portID, channelID)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnChanCloseConfirm indicates an expected call of OnChanCloseConfirm.
func (mr *MockIBCModuleMockRecorder) OnChanCloseConfirm(ctx, portID, channelID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanCloseConfirm", reflect.TypeOf((*MockIBCModule)(nil).OnChanCloseConfirm), ctx, portID, channelID)
}

// OnChanCloseInit mocks base method.
func (m *MockIBCModule) OnChanCloseInit(ctx context.Context, portID, channelID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanCloseInit", ctx, portID, channelID)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnChanCloseInit indicates an expected call of OnChanCloseInit.
func (mr *MockIBCModuleMockRecorder) OnChanCloseInit(ctx, portID, channelID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanCloseInit", reflect.TypeOf((*MockIBCModule)(nil).OnChanCloseInit), ctx, portID, channelID)
}

// OnChanOpenAck mocks base method.
func (m *MockIBCModule) OnChanOpenAck(ctx context.Context, portID, channelID, counterpartyChannelID, counterpartyVersion string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanOpenAck", ctx, portID, channelID, counterpartyChannelID, counterpartyVersion)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnChanOpenAck indicates an expected call of OnChanOpenAck.
func (mr *MockIBCModuleMockRecorder) OnChanOpenAck(ctx, portID, channelID, counterpartyChannelID, counterpartyVersion interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanOpenAck", reflect.TypeOf((*MockIBCModule)(nil).OnChanOpenAck), ctx, portID, channelID, counterpartyChannelID, counterpartyVersion)
}

// OnChanOpenConfirm mocks base method.
func (m *MockIBCModule) OnChanOpenConfirm(ctx context.Context, portID, channelID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanOpenConfirm", ctx, portID, channelID)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnChanOpenConfirm indicates an expected call of OnChanOpenConfirm.
func (mr *MockIBCModuleMockRecorder) OnChanOpenConfirm(ctx, portID, channelID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanOpenConfirm", reflect.TypeOf((*MockIBCModule)(nil).OnChanOpenConfirm), ctx, portID, channelID)
}

// OnChanOpenInit mocks base method.
func (m *MockIBCModule) OnChanOpenInit(ctx context.Context, order types1.Order, connectionHops []string, portID, channelID string, counterparty types1.Counterparty, version string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanOpenInit", ctx, order, connectionHops, portID, channelID, counterparty, version)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OnChanOpenInit indicates an expected call of OnChanOpenInit.
func (mr *MockIBCModuleMockRecorder) OnChanOpenInit(ctx, order, connectionHops, portID, channelID, counterparty, version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanOpenInit", reflect.TypeOf((*MockIBCModule)(nil).OnChanOpenInit), ctx, order, connectionHops, portID, channelID, counterparty, version)
}

// OnChanOpenTry mocks base method.
func (m *MockIBCModule) OnChanOpenTry(ctx context.Context, order types1.Order, connectionHops []string, portID, channelID string, counterparty types1.Counterparty, counterpartyVersion string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanOpenTry", ctx, order, connectionHops, portID, channelID, counterparty, counterpartyVersion)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OnChanOpenTry indicates an expected call of OnChanOpenTry.
func (mr *MockIBCModuleMockRecorder) OnChanOpenTry(ctx, order, connectionHops, portID, channelID, counterparty, counterpartyVersion interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanOpenTry", reflect.TypeOf((*MockIBCModule)(nil).OnChanOpenTry), ctx, order, connectionHops, portID, channelID, counterparty, counterpartyVersion)
}

// OnRecvPacket mocks base method.
func (m *MockIBCModule) OnRecvPacket(ctx context.Context, channelVersion string, packet types1.Packet, relayer types.AccAddress) exported.Acknowledgement {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnRecvPacket", ctx, channelVersion, packet, relayer)
	ret0, _ := ret[0].(exported.Acknowledgement)
	return ret0
}

// OnRecvPacket indicates an expected call of OnRecvPacket.
func (mr *MockIBCModuleMockRecorder) OnRecvPacket(ctx, channelVersion, packet, relayer interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnRecvPacket", reflect.TypeOf((*MockIBCModule)(nil).OnRecvPacket), ctx, channelVersion, packet, relayer)
}

// OnTimeoutPacket mocks base method.
func (m *MockIBCModule) OnTimeoutPacket(ctx context.Context, channelVersion string, packet types1.Packet, relayer types.AccAddress) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnTimeoutPacket", ctx, channelVersion, packet, relayer)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnTimeoutPacket indicates an expected call of OnTimeoutPacket.
func (mr *MockIBCModuleMockRecorder) OnTimeoutPacket(ctx, channelVersion, packet, relayer interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnTimeoutPacket", reflect.TypeOf((*MockIBCModule)(nil).OnTimeoutPacket), ctx, channelVersion, packet, relayer)
}

// MockUpgradableModule is a mock of UpgradableModule interface.
type MockUpgradableModule struct {
	ctrl     *gomock.Controller
	recorder *MockUpgradableModuleMockRecorder
}

// MockUpgradableModuleMockRecorder is the mock recorder for MockUpgradableModule.
type MockUpgradableModuleMockRecorder struct {
	mock *MockUpgradableModule
}

// NewMockUpgradableModule creates a new mock instance.
func NewMockUpgradableModule(ctrl *gomock.Controller) *MockUpgradableModule {
	mock := &MockUpgradableModule{ctrl: ctrl}
	mock.recorder = &MockUpgradableModuleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpgradableModule) EXPECT() *MockUpgradableModuleMockRecorder {
	return m.recorder
}

// OnChanUpgradeAck mocks base method.
func (m *MockUpgradableModule) OnChanUpgradeAck(ctx context.Context, portID, channelID, counterpartyVersion string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanUpgradeAck", ctx, portID, channelID, counterpartyVersion)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnChanUpgradeAck indicates an expected call of OnChanUpgradeAck.
func (mr *MockUpgradableModuleMockRecorder) OnChanUpgradeAck(ctx, portID, channelID, counterpartyVersion interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanUpgradeAck", reflect.TypeOf((*MockUpgradableModule)(nil).OnChanUpgradeAck), ctx, portID, channelID, counterpartyVersion)
}

// OnChanUpgradeInit mocks base method.
func (m *MockUpgradableModule) OnChanUpgradeInit(ctx context.Context, portID, channelID string, proposedOrder types1.Order, proposedConnectionHops []string, proposedVersion string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanUpgradeInit", ctx, portID, channelID, proposedOrder, proposedConnectionHops, proposedVersion)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OnChanUpgradeInit indicates an expected call of OnChanUpgradeInit.
func (mr *MockUpgradableModuleMockRecorder) OnChanUpgradeInit(ctx, portID, channelID, proposedOrder, proposedConnectionHops, proposedVersion interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanUpgradeInit", reflect.TypeOf((*MockUpgradableModule)(nil).OnChanUpgradeInit), ctx, portID, channelID, proposedOrder, proposedConnectionHops, proposedVersion)
}

// OnChanUpgradeOpen mocks base method.
func (m *MockUpgradableModule) OnChanUpgradeOpen(ctx context.Context, portID, channelID string, proposedOrder types1.Order, proposedConnectionHops []string, proposedVersion string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnChanUpgradeOpen", ctx, portID, channelID, proposedOrder, proposedConnectionHops, proposedVersion)
}

// OnChanUpgradeOpen indicates an expected call of OnChanUpgradeOpen.
func (mr *MockUpgradableModuleMockRecorder) OnChanUpgradeOpen(ctx, portID, channelID, proposedOrder, proposedConnectionHops, proposedVersion interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanUpgradeOpen", reflect.TypeOf((*MockUpgradableModule)(nil).OnChanUpgradeOpen), ctx, portID, channelID, proposedOrder, proposedConnectionHops, proposedVersion)
}

// OnChanUpgradeTry mocks base method.
func (m *MockUpgradableModule) OnChanUpgradeTry(ctx context.Context, portID, channelID string, proposedOrder types1.Order, proposedConnectionHops []string, counterpartyVersion string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanUpgradeTry", ctx, portID, channelID, proposedOrder, proposedConnectionHops, counterpartyVersion)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OnChanUpgradeTry indicates an expected call of OnChanUpgradeTry.
func (mr *MockUpgradableModuleMockRecorder) OnChanUpgradeTry(ctx, portID, channelID, proposedOrder, proposedConnectionHops, counterpartyVersion interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanUpgradeTry", reflect.TypeOf((*MockUpgradableModule)(nil).OnChanUpgradeTry), ctx, portID, channelID, proposedOrder, proposedConnectionHops, counterpartyVersion)
}

// MockICS4Wrapper is a mock of ICS4Wrapper interface.
type MockICS4Wrapper struct {
	ctrl     *gomock.Controller
	recorder *MockICS4WrapperMockRecorder
}

// MockICS4WrapperMockRecorder is the mock recorder for MockICS4Wrapper.
type MockICS4WrapperMockRecorder struct {
	mock *MockICS4Wrapper
}

// NewMockICS4Wrapper creates a new mock instance.
func NewMockICS4Wrapper(ctrl *gomock.Controller) *MockICS4Wrapper {
	mock := &MockICS4Wrapper{ctrl: ctrl}
	mock.recorder = &MockICS4WrapperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockICS4Wrapper) EXPECT() *MockICS4WrapperMockRecorder {
	return m.recorder
}

// GetAppVersion mocks base method.
func (m *MockICS4Wrapper) GetAppVersion(ctx context.Context, portID, channelID string) (string, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAppVersion", ctx, portID, channelID)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// GetAppVersion indicates an expected call of GetAppVersion.
func (mr *MockICS4WrapperMockRecorder) GetAppVersion(ctx, portID, channelID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAppVersion", reflect.TypeOf((*MockICS4Wrapper)(nil).GetAppVersion), ctx, portID, channelID)
}

// SendPacket mocks base method.
func (m *MockICS4Wrapper) SendPacket(ctx context.Context, sourcePort, sourceChannel string, timeoutHeight types0.Height, timeoutTimestamp uint64, data []byte) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendPacket", ctx, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, data)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendPacket indicates an expected call of SendPacket.
func (mr *MockICS4WrapperMockRecorder) SendPacket(ctx, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendPacket", reflect.TypeOf((*MockICS4Wrapper)(nil).SendPacket), ctx, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, data)
}

// WriteAcknowledgement mocks base method.
func (m *MockICS4Wrapper) WriteAcknowledgement(ctx context.Context, packet exported.PacketI, ack exported.Acknowledgement) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteAcknowledgement", ctx, packet, ack)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteAcknowledgement indicates an expected call of WriteAcknowledgement.
func (mr *MockICS4WrapperMockRecorder) WriteAcknowledgement(ctx, packet, ack interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteAcknowledgement", reflect.TypeOf((*MockICS4Wrapper)(nil).WriteAcknowledgement), ctx, packet, ack)
}

// MockMiddleware is a mock of Middleware interface.
type MockMiddleware struct {
	ctrl     *gomock.Controller
	recorder *MockMiddlewareMockRecorder
}

// MockMiddlewareMockRecorder is the mock recorder for MockMiddleware.
type MockMiddlewareMockRecorder struct {
	mock *MockMiddleware
}

// NewMockMiddleware creates a new mock instance.
func NewMockMiddleware(ctrl *gomock.Controller) *MockMiddleware {
	mock := &MockMiddleware{ctrl: ctrl}
	mock.recorder = &MockMiddlewareMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMiddleware) EXPECT() *MockMiddlewareMockRecorder {
	return m.recorder
}

// GetAppVersion mocks base method.
func (m *MockMiddleware) GetAppVersion(ctx context.Context, portID, channelID string) (string, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAppVersion", ctx, portID, channelID)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// GetAppVersion indicates an expected call of GetAppVersion.
func (mr *MockMiddlewareMockRecorder) GetAppVersion(ctx, portID, channelID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAppVersion", reflect.TypeOf((*MockMiddleware)(nil).GetAppVersion), ctx, portID, channelID)
}

// OnAcknowledgementPacket mocks base method.
func (m *MockMiddleware) OnAcknowledgementPacket(ctx context.Context, channelVersion string, packet types1.Packet, acknowledgement []byte, relayer types.AccAddress) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnAcknowledgementPacket", ctx, channelVersion, packet, acknowledgement, relayer)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnAcknowledgementPacket indicates an expected call of OnAcknowledgementPacket.
func (mr *MockMiddlewareMockRecorder) OnAcknowledgementPacket(ctx, channelVersion, packet, acknowledgement, relayer interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnAcknowledgementPacket", reflect.TypeOf((*MockMiddleware)(nil).OnAcknowledgementPacket), ctx, channelVersion, packet, acknowledgement, relayer)
}

// OnChanCloseConfirm mocks base method.
func (m *MockMiddleware) OnChanCloseConfirm(ctx context.Context, portID, channelID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanCloseConfirm", ctx, portID, channelID)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnChanCloseConfirm indicates an expected call of OnChanCloseConfirm.
func (mr *MockMiddlewareMockRecorder) OnChanCloseConfirm(ctx, portID, channelID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanCloseConfirm", reflect.TypeOf((*MockMiddleware)(nil).OnChanCloseConfirm), ctx, portID, channelID)
}

// OnChanCloseInit mocks base method.
func (m *MockMiddleware) OnChanCloseInit(ctx context.Context, portID, channelID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanCloseInit", ctx, portID, channelID)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnChanCloseInit indicates an expected call of OnChanCloseInit.
func (mr *MockMiddlewareMockRecorder) OnChanCloseInit(ctx, portID, channelID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanCloseInit", reflect.TypeOf((*MockMiddleware)(nil).OnChanCloseInit), ctx, portID, channelID)
}

// OnChanOpenAck mocks base method.
func (m *MockMiddleware) OnChanOpenAck(ctx context.Context, portID, channelID, counterpartyChannelID, counterpartyVersion string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanOpenAck", ctx, portID, channelID, counterpartyChannelID, counterpartyVersion)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnChanOpenAck indicates an expected call of OnChanOpenAck.
func (mr *MockMiddlewareMockRecorder) OnChanOpenAck(ctx, portID, channelID, counterpartyChannelID, counterpartyVersion interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanOpenAck", reflect.TypeOf((*MockMiddleware)(nil).OnChanOpenAck), ctx, portID, channelID, counterpartyChannelID, counterpartyVersion)
}

// OnChanOpenConfirm mocks base method.
func (m *MockMiddleware) OnChanOpenConfirm(ctx context.Context, portID, channelID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanOpenConfirm", ctx, portID, channelID)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnChanOpenConfirm indicates an expected call of OnChanOpenConfirm.
func (mr *MockMiddlewareMockRecorder) OnChanOpenConfirm(ctx, portID, channelID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanOpenConfirm", reflect.TypeOf((*MockMiddleware)(nil).OnChanOpenConfirm), ctx, portID, channelID)
}

// OnChanOpenInit mocks base method.
func (m *MockMiddleware) OnChanOpenInit(ctx context.Context, order types1.Order, connectionHops []string, portID, channelID string, counterparty types1.Counterparty, version string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanOpenInit", ctx, order, connectionHops, portID, channelID, counterparty, version)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OnChanOpenInit indicates an expected call of OnChanOpenInit.
func (mr *MockMiddlewareMockRecorder) OnChanOpenInit(ctx, order, connectionHops, portID, channelID, counterparty, version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanOpenInit", reflect.TypeOf((*MockMiddleware)(nil).OnChanOpenInit), ctx, order, connectionHops, portID, channelID, counterparty, version)
}

// OnChanOpenTry mocks base method.
func (m *MockMiddleware) OnChanOpenTry(ctx context.Context, order types1.Order, connectionHops []string, portID, channelID string, counterparty types1.Counterparty, counterpartyVersion string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnChanOpenTry", ctx, order, connectionHops, portID, channelID, counterparty, counterpartyVersion)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OnChanOpenTry indicates an expected call of OnChanOpenTry.
func (mr *MockMiddlewareMockRecorder) OnChanOpenTry(ctx, order, connectionHops, portID, channelID, counterparty, counterpartyVersion interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnChanOpenTry", reflect.TypeOf((*MockMiddleware)(nil).OnChanOpenTry), ctx, order, connectionHops, portID, channelID, counterparty, counterpartyVersion)
}

// OnRecvPacket mocks base method.
func (m *MockMiddleware) OnRecvPacket(ctx context.Context, channelVersion string, packet types1.Packet, relayer types.AccAddress) exported.Acknowledgement {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnRecvPacket", ctx, channelVersion, packet, relayer)
	ret0, _ := ret[0].(exported.Acknowledgement)
	return ret0
}

// OnRecvPacket indicates an expected call of OnRecvPacket.
func (mr *MockMiddlewareMockRecorder) OnRecvPacket(ctx, channelVersion, packet, relayer interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnRecvPacket", reflect.TypeOf((*MockMiddleware)(nil).OnRecvPacket), ctx, channelVersion, packet, relayer)
}

// OnTimeoutPacket mocks base method.
func (m *MockMiddleware) OnTimeoutPacket(ctx context.Context, channelVersion string, packet types1.Packet, relayer types.AccAddress) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnTimeoutPacket", ctx, channelVersion, packet, relayer)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnTimeoutPacket indicates an expected call of OnTimeoutPacket.
func (mr *MockMiddlewareMockRecorder) OnTimeoutPacket(ctx, channelVersion, packet, relayer interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnTimeoutPacket", reflect.TypeOf((*MockMiddleware)(nil).OnTimeoutPacket), ctx, channelVersion, packet, relayer)
}

// SendPacket mocks base method.
func (m *MockMiddleware) SendPacket(ctx context.Context, sourcePort, sourceChannel string, timeoutHeight types0.Height, timeoutTimestamp uint64, data []byte) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendPacket", ctx, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, data)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendPacket indicates an expected call of SendPacket.
func (mr *MockMiddlewareMockRecorder) SendPacket(ctx, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendPacket", reflect.TypeOf((*MockMiddleware)(nil).SendPacket), ctx, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, data)
}

// WriteAcknowledgement mocks base method.
func (m *MockMiddleware) WriteAcknowledgement(ctx context.Context, packet exported.PacketI, ack exported.Acknowledgement) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteAcknowledgement", ctx, packet, ack)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteAcknowledgement indicates an expected call of WriteAcknowledgement.
func (mr *MockMiddlewareMockRecorder) WriteAcknowledgement(ctx, packet, ack interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteAcknowledgement", reflect.TypeOf((*MockMiddleware)(nil).WriteAcknowledgement), ctx, packet, ack)
}

// MockPacketDataUnmarshaler is a mock of PacketDataUnmarshaler interface.
type MockPacketDataUnmarshaler struct {
	ctrl     *gomock.Controller
	recorder *MockPacketDataUnmarshalerMockRecorder
}

// MockPacketDataUnmarshalerMockRecorder is the mock recorder for MockPacketDataUnmarshaler.
type MockPacketDataUnmarshalerMockRecorder struct {
	mock *MockPacketDataUnmarshaler
}

// NewMockPacketDataUnmarshaler creates a new mock instance.
func NewMockPacketDataUnmarshaler(ctrl *gomock.Controller) *MockPacketDataUnmarshaler {
	mock := &MockPacketDataUnmarshaler{ctrl: ctrl}
	mock.recorder = &MockPacketDataUnmarshalerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPacketDataUnmarshaler) EXPECT() *MockPacketDataUnmarshalerMockRecorder {
	return m.recorder
}

// UnmarshalPacketData mocks base method.
func (m *MockPacketDataUnmarshaler) UnmarshalPacketData(ctx context.Context, portID, channelID string, bz []byte) (interface{}, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnmarshalPacketData", ctx, portID, channelID, bz)
	ret0, _ := ret[0].(interface{})
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UnmarshalPacketData indicates an expected call of UnmarshalPacketData.
func (mr *MockPacketDataUnmarshalerMockRecorder) UnmarshalPacketData(ctx, portID, channelID, bz interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnmarshalPacketData", reflect.TypeOf((*MockPacketDataUnmarshaler)(nil).UnmarshalPacketData), ctx, portID, channelID, bz)
}
