package genesis

import (
	"encoding/json"
	"fmt"
	"github.com/celestiaorg/celestia-app/v4/app/encoding"
	tmproto "github.com/cometbft/cometbft/proto/tendermint/types"
	coretypes "github.com/cometbft/cometbft/types"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
	genutiltypes "github.com/cosmos/cosmos-sdk/x/genutil/types"
	"io"
	"os"
	"time"
)

// DocumentLegacy will create a valid genesis doc with funded addresses.
func DocumentLegacy(
	defaultGenesis map[string]json.RawMessage,
	ecfg encoding.Config,
	params *tmproto.ConsensusParams,
	chainID string,
	gentxs []json.RawMessage,
	accounts []Account,
	genesisTime time.Time,
) (*coretypes.GenesisDoc, error) {

	genutilGenState := genutiltypes.DefaultGenesisState()
	genutilGenState.GenTxs = gentxs

	genBals, genAccs, err := accountsToSDKTypes(accounts)
	if err != nil {
		return nil, fmt.Errorf("converting accounts into sdk types: %w", err)
	}

	sdkAccounts, err := authtypes.PackAccounts(genAccs)
	if err != nil {
		return nil, fmt.Errorf("packing accounts: %w", err)
	}

	authGenState := authtypes.DefaultGenesisState()
	authGenState.Accounts = append(authGenState.Accounts, sdkAccounts...)

	state := defaultGenesis
	state[authtypes.ModuleName] = ecfg.Codec.MustMarshalJSON(authGenState)
	state[banktypes.ModuleName] = getLegacyBankState(genBals)
	state[genutiltypes.ModuleName] = ecfg.Codec.MustMarshalJSON(genutilGenState)

	appStateBz, err := json.MarshalIndent(state, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("marshalling genesis state: %w", err)
	}

	cp := coretypes.ConsensusParamsFromProto(*params)

	genesisDoc := &coretypes.GenesisDoc{
		ChainID:         chainID,
		AppState:        appStateBz,
		ConsensusParams: &cp,
		GenesisTime:     genesisTime,
	}

	return genesisDoc, nil
}

// getLegacyBankState returns valid bytes for a pre v4 bank genesis appstate.
func getLegacyBankState(genBals []banktypes.Balance) []byte {
	bankGenState := banktypes.DefaultGenesisState()
	bankGenState.Balances = append(bankGenState.Balances, genBals...)
	bankGenState.Balances = banktypes.SanitizeGenesisBalances(bankGenState.Balances)

	// the SendEnabled field was moved from Params.SendEnabled to the top level.
	// we need to re-vert this change in order to convert a v4 genesis app state to a valid v3 genesis app state.
	bankGenState.Params.SendEnabled = make([]*banktypes.SendEnabled, 0)
	for _, se := range bankGenState.SendEnabled {
		bankGenState.Params.SendEnabled = append(bankGenState.Params.SendEnabled, &se)
	}
	bankGenState.SendEnabled = nil

	bz, err := json.Marshal(bankGenState)
	if err != nil {
		panic(err)
	}

	// "send_enabled" does not have the `omitempty` tag, so we need to remove it
	// explicitly and re-marshal.
	withoutSendEnabled, err := removeKeyFromMapBz(bz, "send_enabled")
	if err != nil {
		panic(err)
	}

	return withoutSendEnabled

}

// removeKeyFromMapBz removes specified keys from a JSON-encoded byte slice and returns the updated byte slice or an error.
func removeKeyFromMapBz(bz []byte, keys ...string) ([]byte, error) {
	var jsonMap map[string]interface{}
	if err := json.Unmarshal(bz, &jsonMap); err != nil {
		return nil, fmt.Errorf("failed to unmarshal: %w", err)
	}

	for _, key := range keys {
		delete(jsonMap, key)
	}

	bz, err := json.Marshal(jsonMap)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal after key removal: %w", err)
	}
	return bz, nil
}

// LoadV3GenesisAppState returns a genesis appState generated by a v3 binary.
// this is used as a starting point when providing a genesis app state to an embedded v3 application in E2E tests.
func LoadV3GenesisAppState() []byte {
	// NOTE: when e2e tests are _test.go files again, this can be loaded with just v3_genesis_app_state.json
	// as it will be in n test file directory.
	const v3GenesisAppStateFilePath = "test/e2e/test_data/v3genesisAppState.json"
	file, err := os.Open(v3GenesisAppStateFilePath)
	if err != nil {
		panic(fmt.Errorf("failed to open file: %w", err))
	}
	defer file.Close()

	bz, err := io.ReadAll(file)
	if err != nil {
		panic(fmt.Errorf("failed to read file: %w", err))
	}
	return bz
}
